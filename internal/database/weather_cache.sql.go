// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: weather_cache.sql

package database

import (
	"context"
	"database/sql"
)

const deleteDuplicateWeather = `-- name: DeleteDuplicateWeather :exec
DELETE FROM weather_cache
WHERE id NOT IN (
    SELECT MAX(id)
    FROM weather_cache
    GROUP BY city_id
)
`

func (q *Queries) DeleteDuplicateWeather(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteDuplicateWeather)
	return err
}

const deleteOldWeather = `-- name: DeleteOldWeather :exec
DELETE FROM weather_cache
WHERE fetched_at < ?
`

func (q *Queries) DeleteOldWeather(ctx context.Context, fetchedAt sql.NullInt64) error {
	_, err := q.db.ExecContext(ctx, deleteOldWeather, fetchedAt)
	return err
}

const getFreshWeatherByCity = `-- name: GetFreshWeatherByCity :one
SELECT id, city_id, city_name, country, lat, lon, weather_main, weather_desc, weather_icon, "temp", feels_like, temp_min, temp_max, humidity, pressure, wind_speed, wind_deg, wind_gust, rain_1h, cloudiness, visibility, weather_time, fetched_at, timezone, weather_id, sea_level, ground_level, sunrise, sunset
FROM weather_cache
WHERE city_name = ?
  AND fetched_at >= ?
ORDER BY fetched_at DESC
LIMIT 1
`

type GetFreshWeatherByCityParams struct {
	CityName  sql.NullString
	FetchedAt sql.NullInt64
}

func (q *Queries) GetFreshWeatherByCity(ctx context.Context, arg GetFreshWeatherByCityParams) (WeatherCache, error) {
	row := q.db.QueryRowContext(ctx, getFreshWeatherByCity, arg.CityName, arg.FetchedAt)
	var i WeatherCache
	err := row.Scan(
		&i.ID,
		&i.CityID,
		&i.CityName,
		&i.Country,
		&i.Lat,
		&i.Lon,
		&i.WeatherMain,
		&i.WeatherDesc,
		&i.WeatherIcon,
		&i.Temp,
		&i.FeelsLike,
		&i.TempMin,
		&i.TempMax,
		&i.Humidity,
		&i.Pressure,
		&i.WindSpeed,
		&i.WindDeg,
		&i.WindGust,
		&i.Rain1h,
		&i.Cloudiness,
		&i.Visibility,
		&i.WeatherTime,
		&i.FetchedAt,
		&i.Timezone,
		&i.WeatherID,
		&i.SeaLevel,
		&i.GroundLevel,
		&i.Sunrise,
		&i.Sunset,
	)
	return i, err
}

const getFreshWeatherByCoords = `-- name: GetFreshWeatherByCoords :one
SELECT id, city_id, city_name, country, lat, lon, weather_main, weather_desc, weather_icon, "temp", feels_like, temp_min, temp_max, humidity, pressure, wind_speed, wind_deg, wind_gust, rain_1h, cloudiness, visibility, weather_time, fetched_at, timezone, weather_id, sea_level, ground_level, sunrise, sunset
FROM weather_cache
WHERE lat >= ?
  AND lat <= ?
  AND lon >= ?
  AND lon <= ?
  AND fetched_at >= ?
ORDER BY fetched_at DESC
LIMIT 1
`

type GetFreshWeatherByCoordsParams struct {
	Lat       sql.NullFloat64
	Lat_2     sql.NullFloat64
	Lon       sql.NullFloat64
	Lon_2     sql.NullFloat64
	FetchedAt sql.NullInt64
}

func (q *Queries) GetFreshWeatherByCoords(ctx context.Context, arg GetFreshWeatherByCoordsParams) (WeatherCache, error) {
	row := q.db.QueryRowContext(ctx, getFreshWeatherByCoords,
		arg.Lat,
		arg.Lat_2,
		arg.Lon,
		arg.Lon_2,
		arg.FetchedAt,
	)
	var i WeatherCache
	err := row.Scan(
		&i.ID,
		&i.CityID,
		&i.CityName,
		&i.Country,
		&i.Lat,
		&i.Lon,
		&i.WeatherMain,
		&i.WeatherDesc,
		&i.WeatherIcon,
		&i.Temp,
		&i.FeelsLike,
		&i.TempMin,
		&i.TempMax,
		&i.Humidity,
		&i.Pressure,
		&i.WindSpeed,
		&i.WindDeg,
		&i.WindGust,
		&i.Rain1h,
		&i.Cloudiness,
		&i.Visibility,
		&i.WeatherTime,
		&i.FetchedAt,
		&i.Timezone,
		&i.WeatherID,
		&i.SeaLevel,
		&i.GroundLevel,
		&i.Sunrise,
		&i.Sunset,
	)
	return i, err
}

const getLatestWeatherByCity = `-- name: GetLatestWeatherByCity :one
SELECT id, city_id, city_name, country, lat, lon, weather_main, weather_desc, weather_icon, "temp", feels_like, temp_min, temp_max, humidity, pressure, wind_speed, wind_deg, wind_gust, rain_1h, cloudiness, visibility, weather_time, fetched_at, timezone, weather_id, sea_level, ground_level, sunrise, sunset
FROM weather_cache
WHERE city_name = ?
ORDER BY fetched_at DESC
LIMIT 1
`

func (q *Queries) GetLatestWeatherByCity(ctx context.Context, cityName sql.NullString) (WeatherCache, error) {
	row := q.db.QueryRowContext(ctx, getLatestWeatherByCity, cityName)
	var i WeatherCache
	err := row.Scan(
		&i.ID,
		&i.CityID,
		&i.CityName,
		&i.Country,
		&i.Lat,
		&i.Lon,
		&i.WeatherMain,
		&i.WeatherDesc,
		&i.WeatherIcon,
		&i.Temp,
		&i.FeelsLike,
		&i.TempMin,
		&i.TempMax,
		&i.Humidity,
		&i.Pressure,
		&i.WindSpeed,
		&i.WindDeg,
		&i.WindGust,
		&i.Rain1h,
		&i.Cloudiness,
		&i.Visibility,
		&i.WeatherTime,
		&i.FetchedAt,
		&i.Timezone,
		&i.WeatherID,
		&i.SeaLevel,
		&i.GroundLevel,
		&i.Sunrise,
		&i.Sunset,
	)
	return i, err
}

const getLatestWeatherByCityID = `-- name: GetLatestWeatherByCityID :one
SELECT id, city_id, city_name, country, lat, lon, weather_main, weather_desc, weather_icon, "temp", feels_like, temp_min, temp_max, humidity, pressure, wind_speed, wind_deg, wind_gust, rain_1h, cloudiness, visibility, weather_time, fetched_at, timezone, weather_id, sea_level, ground_level, sunrise, sunset
FROM weather_cache
WHERE city_id = ?
ORDER BY fetched_at DESC
LIMIT 1
`

func (q *Queries) GetLatestWeatherByCityID(ctx context.Context, cityID sql.NullInt64) (WeatherCache, error) {
	row := q.db.QueryRowContext(ctx, getLatestWeatherByCityID, cityID)
	var i WeatherCache
	err := row.Scan(
		&i.ID,
		&i.CityID,
		&i.CityName,
		&i.Country,
		&i.Lat,
		&i.Lon,
		&i.WeatherMain,
		&i.WeatherDesc,
		&i.WeatherIcon,
		&i.Temp,
		&i.FeelsLike,
		&i.TempMin,
		&i.TempMax,
		&i.Humidity,
		&i.Pressure,
		&i.WindSpeed,
		&i.WindDeg,
		&i.WindGust,
		&i.Rain1h,
		&i.Cloudiness,
		&i.Visibility,
		&i.WeatherTime,
		&i.FetchedAt,
		&i.Timezone,
		&i.WeatherID,
		&i.SeaLevel,
		&i.GroundLevel,
		&i.Sunrise,
		&i.Sunset,
	)
	return i, err
}

const getLatestWeatherByCoords = `-- name: GetLatestWeatherByCoords :one
SELECT id, city_id, city_name, country, lat, lon, weather_main, weather_desc, weather_icon, "temp", feels_like, temp_min, temp_max, humidity, pressure, wind_speed, wind_deg, wind_gust, rain_1h, cloudiness, visibility, weather_time, fetched_at, timezone, weather_id, sea_level, ground_level, sunrise, sunset
FROM weather_cache
WHERE lat >= ?
  AND lat <= ?
  AND lon >= ?
  AND lon <= ?
  AND fetched_at >= ?
ORDER BY fetched_at DESC
LIMIT 1
`

type GetLatestWeatherByCoordsParams struct {
	Lat       sql.NullFloat64
	Lat_2     sql.NullFloat64
	Lon       sql.NullFloat64
	Lon_2     sql.NullFloat64
	FetchedAt sql.NullInt64
}

func (q *Queries) GetLatestWeatherByCoords(ctx context.Context, arg GetLatestWeatherByCoordsParams) (WeatherCache, error) {
	row := q.db.QueryRowContext(ctx, getLatestWeatherByCoords,
		arg.Lat,
		arg.Lat_2,
		arg.Lon,
		arg.Lon_2,
		arg.FetchedAt,
	)
	var i WeatherCache
	err := row.Scan(
		&i.ID,
		&i.CityID,
		&i.CityName,
		&i.Country,
		&i.Lat,
		&i.Lon,
		&i.WeatherMain,
		&i.WeatherDesc,
		&i.WeatherIcon,
		&i.Temp,
		&i.FeelsLike,
		&i.TempMin,
		&i.TempMax,
		&i.Humidity,
		&i.Pressure,
		&i.WindSpeed,
		&i.WindDeg,
		&i.WindGust,
		&i.Rain1h,
		&i.Cloudiness,
		&i.Visibility,
		&i.WeatherTime,
		&i.FetchedAt,
		&i.Timezone,
		&i.WeatherID,
		&i.SeaLevel,
		&i.GroundLevel,
		&i.Sunrise,
		&i.Sunset,
	)
	return i, err
}

const getWeatherHistoryByCity = `-- name: GetWeatherHistoryByCity :many
SELECT id, city_id, city_name, country, lat, lon, weather_main, weather_desc, weather_icon, "temp", feels_like, temp_min, temp_max, humidity, pressure, wind_speed, wind_deg, wind_gust, rain_1h, cloudiness, visibility, weather_time, fetched_at, timezone, weather_id, sea_level, ground_level, sunrise, sunset
FROM weather_cache
WHERE city_name = ?
ORDER BY fetched_at DESC
LIMIT ?
`

type GetWeatherHistoryByCityParams struct {
	CityName sql.NullString
	Limit    int64
}

func (q *Queries) GetWeatherHistoryByCity(ctx context.Context, arg GetWeatherHistoryByCityParams) ([]WeatherCache, error) {
	rows, err := q.db.QueryContext(ctx, getWeatherHistoryByCity, arg.CityName, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WeatherCache
	for rows.Next() {
		var i WeatherCache
		if err := rows.Scan(
			&i.ID,
			&i.CityID,
			&i.CityName,
			&i.Country,
			&i.Lat,
			&i.Lon,
			&i.WeatherMain,
			&i.WeatherDesc,
			&i.WeatherIcon,
			&i.Temp,
			&i.FeelsLike,
			&i.TempMin,
			&i.TempMax,
			&i.Humidity,
			&i.Pressure,
			&i.WindSpeed,
			&i.WindDeg,
			&i.WindGust,
			&i.Rain1h,
			&i.Cloudiness,
			&i.Visibility,
			&i.WeatherTime,
			&i.FetchedAt,
			&i.Timezone,
			&i.WeatherID,
			&i.SeaLevel,
			&i.GroundLevel,
			&i.Sunrise,
			&i.Sunset,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const insertWeather = `-- name: InsertWeather :exec
INSERT INTO weather_cache (
    city_id,
    city_name,
    country,
    lat,
    lon,
    weather_main,
    weather_desc,
    weather_icon,
    weather_id,
    temp,
    feels_like,
    temp_min,
    temp_max,
    humidity,
    pressure,
    sea_level,
    ground_level,
    wind_speed,
    wind_deg,
    wind_gust,
    rain_1h,
    cloudiness,
    visibility,
    sunrise,
    sunset,
    weather_time,
    fetched_at,
    timezone
) VALUES (
    ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?
)
`

type InsertWeatherParams struct {
	CityID      sql.NullInt64
	CityName    sql.NullString
	Country     sql.NullString
	Lat         sql.NullFloat64
	Lon         sql.NullFloat64
	WeatherMain sql.NullString
	WeatherDesc sql.NullString
	WeatherIcon sql.NullString
	WeatherID   sql.NullInt64
	Temp        sql.NullFloat64
	FeelsLike   sql.NullFloat64
	TempMin     sql.NullFloat64
	TempMax     sql.NullFloat64
	Humidity    sql.NullInt64
	Pressure    sql.NullInt64
	SeaLevel    sql.NullInt64
	GroundLevel sql.NullInt64
	WindSpeed   sql.NullFloat64
	WindDeg     sql.NullInt64
	WindGust    sql.NullFloat64
	Rain1h      sql.NullFloat64
	Cloudiness  sql.NullInt64
	Visibility  sql.NullInt64
	Sunrise     sql.NullInt64
	Sunset      sql.NullInt64
	WeatherTime sql.NullInt64
	FetchedAt   sql.NullInt64
	Timezone    sql.NullInt64
}

func (q *Queries) InsertWeather(ctx context.Context, arg InsertWeatherParams) error {
	_, err := q.db.ExecContext(ctx, insertWeather,
		arg.CityID,
		arg.CityName,
		arg.Country,
		arg.Lat,
		arg.Lon,
		arg.WeatherMain,
		arg.WeatherDesc,
		arg.WeatherIcon,
		arg.WeatherID,
		arg.Temp,
		arg.FeelsLike,
		arg.TempMin,
		arg.TempMax,
		arg.Humidity,
		arg.Pressure,
		arg.SeaLevel,
		arg.GroundLevel,
		arg.WindSpeed,
		arg.WindDeg,
		arg.WindGust,
		arg.Rain1h,
		arg.Cloudiness,
		arg.Visibility,
		arg.Sunrise,
		arg.Sunset,
		arg.WeatherTime,
		arg.FetchedAt,
		arg.Timezone,
	)
	return err
}
